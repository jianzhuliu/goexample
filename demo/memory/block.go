package main

import "fmt"
import "runtime"

var p *int

func main() {
	done := make(chan bool)
	// done通道将被使用在主协程和下面将要
	// 创建的新协程中，所以它将被开辟在堆上。

	go func() {
		x, y, z := 123, 456, 789
		_ = z  // z可以被安全地开辟在栈上。
		p = &x // 因为x和y都会将曾经被包级指针p所引用过，
		p = &y // 因此，它们都将开辟在堆上。

		// 到这里，x已经不再被任何其它值所引用。或者说承载
		// 它的内存块已经不再被使用。此内存块可以被回收了。

		p = nil
		// 到这里，y已经不再被任何其它值所引用。
		// 承载它的内存块可以被回收了。

		done <- true
	}()

	<-done
	// 到这里，done已经不再被任何其它值所引用。一个
	// 聪明的编译器将认为承载它的内存块可以被回收了。

	// ...

	// 假设此切片的长度很大，以至于它的元素
	// 将被开辟在堆上。
	bs := make([]byte, 1<<31)

	// 一个聪明的编译器将觉察到bs的底层元素
	// 部分已经不会再被使用，而正确地认为bs的
	// 底层元素部分在此刻可以被安全地回收了。

	fmt.Println(len(bs))

	//可以调用,保存不必回收
	runtime.KeepAlive(&bs)
	// 对于这个特定的例子，也可以调用
	// runtime.KeepAlive(bs)。

	// ...
}
